# Generated from nl.g4 by ANTLR 4.9.3
# encoding: utf-8
from antlr4 import *
from io import StringIO
import sys
if sys.version_info[1] > 5:
	from typing import TextIO
else:
	from typing.io import TextIO


def serializedATN():
    with StringIO() as buf:
        buf.write("\3\u608b\ua72a\u8133\ub9ed\u417c\u3be7\u7786\u5964\3B")
        buf.write("\u00fe\4\2\t\2\4\3\t\3\4\4\t\4\4\5\t\5\4\6\t\6\4\7\t\7")
        buf.write("\4\b\t\b\4\t\t\t\4\n\t\n\4\13\t\13\4\f\t\f\4\r\t\r\4\16")
        buf.write("\t\16\4\17\t\17\4\20\t\20\4\21\t\21\4\22\t\22\4\23\t\23")
        buf.write("\4\24\t\24\4\25\t\25\4\26\t\26\4\27\t\27\4\30\t\30\4\31")
        buf.write("\t\31\3\2\3\2\3\2\7\2\66\n\2\f\2\16\29\13\2\3\2\3\2\7")
        buf.write("\2=\n\2\f\2\16\2@\13\2\3\2\6\2C\n\2\r\2\16\2D\3\2\5\2")
        buf.write("H\n\2\3\2\3\2\3\2\5\2M\n\2\3\3\3\3\3\4\3\4\3\4\3\4\3\4")
        buf.write("\3\4\3\4\3\4\3\4\3\4\3\4\3\4\5\4]\n\4\3\5\3\5\3\5\3\5")
        buf.write("\5\5c\n\5\3\6\3\6\3\7\3\7\3\7\3\7\3\7\3\7\3\7\5\7n\n\7")
        buf.write("\3\b\5\bq\n\b\3\b\3\b\3\b\5\bv\n\b\3\b\6\by\n\b\r\b\16")
        buf.write("\bz\3\b\3\b\5\b\177\n\b\3\b\7\b\u0082\n\b\f\b\16\b\u0085")
        buf.write("\13\b\3\b\3\b\5\b\u0089\n\b\3\b\3\b\5\b\u008d\n\b\3\t")
        buf.write("\5\t\u0090\n\t\3\t\3\t\3\t\5\t\u0095\n\t\3\t\6\t\u0098")
        buf.write("\n\t\r\t\16\t\u0099\3\t\3\t\5\t\u009e\n\t\3\t\7\t\u00a1")
        buf.write("\n\t\f\t\16\t\u00a4\13\t\3\t\3\t\5\t\u00a8\n\t\3\t\3\t")
        buf.write("\5\t\u00ac\n\t\3\n\3\n\3\n\5\n\u00b1\n\n\3\n\3\n\3\n\3")
        buf.write("\n\7\n\u00b7\n\n\f\n\16\n\u00ba\13\n\3\13\3\13\3\13\5")
        buf.write("\13\u00bf\n\13\3\13\3\13\3\13\7\13\u00c4\n\13\f\13\16")
        buf.write("\13\u00c7\13\13\3\f\3\f\3\r\3\r\3\16\3\16\3\17\3\17\3")
        buf.write("\17\5\17\u00d2\n\17\3\20\3\20\3\21\3\21\3\22\3\22\3\23")
        buf.write("\3\23\3\24\3\24\3\25\3\25\3\26\3\26\5\26\u00e2\n\26\3")
        buf.write("\27\3\27\3\30\3\30\3\30\3\30\3\30\3\30\3\30\3\30\3\30")
        buf.write("\3\30\3\30\3\30\3\30\3\30\3\30\3\30\3\30\3\30\3\30\3\30")
        buf.write("\5\30\u00fa\n\30\3\31\3\31\3\31\2\2\32\2\4\6\b\n\f\16")
        buf.write("\20\22\24\26\30\32\34\36 \"$&(*,.\60\2\n\3\2\4\t\3\2\23")
        buf.write("\34\3\2\35 \3\2!(\3\2)\60\3\2\61\63\3\2\65\66\3\2\67;")
        buf.write("\2\u0117\2L\3\2\2\2\4N\3\2\2\2\6\\\3\2\2\2\bb\3\2\2\2")
        buf.write("\nd\3\2\2\2\fm\3\2\2\2\16p\3\2\2\2\20\u008f\3\2\2\2\22")
        buf.write("\u00b0\3\2\2\2\24\u00be\3\2\2\2\26\u00c8\3\2\2\2\30\u00ca")
        buf.write("\3\2\2\2\32\u00cc\3\2\2\2\34\u00d1\3\2\2\2\36\u00d3\3")
        buf.write("\2\2\2 \u00d5\3\2\2\2\"\u00d7\3\2\2\2$\u00d9\3\2\2\2&")
        buf.write("\u00db\3\2\2\2(\u00dd\3\2\2\2*\u00e1\3\2\2\2,\u00e3\3")
        buf.write("\2\2\2.\u00f9\3\2\2\2\60\u00fb\3\2\2\2\62\63\5\4\3\2\63")
        buf.write("\67\5\16\b\2\64\66\5*\26\2\65\64\3\2\2\2\669\3\2\2\2\67")
        buf.write("\65\3\2\2\2\678\3\2\2\28:\3\2\2\29\67\3\2\2\2:>\5\32\16")
        buf.write("\2;=\5*\26\2<;\3\2\2\2=@\3\2\2\2><\3\2\2\2>?\3\2\2\2?")
        buf.write("B\3\2\2\2@>\3\2\2\2AC\5\6\4\2BA\3\2\2\2CD\3\2\2\2DB\3")
        buf.write("\2\2\2DE\3\2\2\2EG\3\2\2\2FH\5\60\31\2GF\3\2\2\2GH\3\2")
        buf.write("\2\2HI\3\2\2\2IJ\7\2\2\3JM\3\2\2\2KM\7A\2\2L\62\3\2\2")
        buf.write("\2LK\3\2\2\2M\3\3\2\2\2NO\7\3\2\2O\5\3\2\2\2PQ\5\f\7\2")
        buf.write("QR\5\20\t\2R]\3\2\2\2ST\5\f\7\2TU\5\b\5\2U]\3\2\2\2VW")
        buf.write("\5\n\6\2WX\5\20\t\2X]\3\2\2\2YZ\5\n\6\2Z[\5\b\5\2[]\3")
        buf.write("\2\2\2\\P\3\2\2\2\\S\3\2\2\2\\V\3\2\2\2\\Y\3\2\2\2]\7")
        buf.write("\3\2\2\2^_\5\16\b\2_`\5.\30\2`c\3\2\2\2ac\5.\30\2b^\3")
        buf.write("\2\2\2ba\3\2\2\2c\t\3\2\2\2de\t\2\2\2e\13\3\2\2\2fn\7")
        buf.write("\n\2\2gn\7\13\2\2hn\5(\25\2in\7\f\2\2jn\7\r\2\2kn\7\16")
        buf.write("\2\2ln\7\17\2\2mf\3\2\2\2mg\3\2\2\2mh\3\2\2\2mi\3\2\2")
        buf.write("\2mj\3\2\2\2mk\3\2\2\2ml\3\2\2\2n\r\3\2\2\2oq\5\26\f\2")
        buf.write("po\3\2\2\2pq\3\2\2\2qr\3\2\2\2r\u008c\5\22\n\2su\7\20")
        buf.write("\2\2tv\5\26\f\2ut\3\2\2\2uv\3\2\2\2vw\3\2\2\2wy\5\22\n")
        buf.write("\2xs\3\2\2\2yz\3\2\2\2zx\3\2\2\2z{\3\2\2\2{\u008d\3\2")
        buf.write("\2\2|~\7\20\2\2}\177\5\26\f\2~}\3\2\2\2~\177\3\2\2\2\177")
        buf.write("\u0080\3\2\2\2\u0080\u0082\5\22\n\2\u0081|\3\2\2\2\u0082")
        buf.write("\u0085\3\2\2\2\u0083\u0081\3\2\2\2\u0083\u0084\3\2\2\2")
        buf.write("\u0084\u0086\3\2\2\2\u0085\u0083\3\2\2\2\u0086\u0088\5")
        buf.write("\30\r\2\u0087\u0089\5\26\f\2\u0088\u0087\3\2\2\2\u0088")
        buf.write("\u0089\3\2\2\2\u0089\u008a\3\2\2\2\u008a\u008b\5\22\n")
        buf.write("\2\u008b\u008d\3\2\2\2\u008cx\3\2\2\2\u008c\u0083\3\2")
        buf.write("\2\2\u008c\u008d\3\2\2\2\u008d\17\3\2\2\2\u008e\u0090")
        buf.write("\5\26\f\2\u008f\u008e\3\2\2\2\u008f\u0090\3\2\2\2\u0090")
        buf.write("\u0091\3\2\2\2\u0091\u00ab\5\24\13\2\u0092\u0094\7\20")
        buf.write("\2\2\u0093\u0095\5\26\f\2\u0094\u0093\3\2\2\2\u0094\u0095")
        buf.write("\3\2\2\2\u0095\u0096\3\2\2\2\u0096\u0098\5\24\13\2\u0097")
        buf.write("\u0092\3\2\2\2\u0098\u0099\3\2\2\2\u0099\u0097\3\2\2\2")
        buf.write("\u0099\u009a\3\2\2\2\u009a\u00ac\3\2\2\2\u009b\u009d\7")
        buf.write("\20\2\2\u009c\u009e\5\26\f\2\u009d\u009c\3\2\2\2\u009d")
        buf.write("\u009e\3\2\2\2\u009e\u009f\3\2\2\2\u009f\u00a1\5\24\13")
        buf.write("\2\u00a0\u009b\3\2\2\2\u00a1\u00a4\3\2\2\2\u00a2\u00a0")
        buf.write("\3\2\2\2\u00a2\u00a3\3\2\2\2\u00a3\u00a5\3\2\2\2\u00a4")
        buf.write("\u00a2\3\2\2\2\u00a5\u00a7\5\30\r\2\u00a6\u00a8\5\26\f")
        buf.write("\2\u00a7\u00a6\3\2\2\2\u00a7\u00a8\3\2\2\2\u00a8\u00a9")
        buf.write("\3\2\2\2\u00a9\u00aa\5\24\13\2\u00aa\u00ac\3\2\2\2\u00ab")
        buf.write("\u0097\3\2\2\2\u00ab\u00a2\3\2\2\2\u00ab\u00ac\3\2\2\2")
        buf.write("\u00ac\21\3\2\2\2\u00ad\u00b1\5\34\17\2\u00ae\u00b1\5")
        buf.write("$\23\2\u00af\u00b1\5(\25\2\u00b0\u00ad\3\2\2\2\u00b0\u00ae")
        buf.write("\3\2\2\2\u00b0\u00af\3\2\2\2\u00b1\u00b8\3\2\2\2\u00b2")
        buf.write("\u00b7\5\34\17\2\u00b3\u00b7\5$\23\2\u00b4\u00b7\5&\24")
        buf.write("\2\u00b5\u00b7\5(\25\2\u00b6\u00b2\3\2\2\2\u00b6\u00b3")
        buf.write("\3\2\2\2\u00b6\u00b4\3\2\2\2\u00b6\u00b5\3\2\2\2\u00b7")
        buf.write("\u00ba\3\2\2\2\u00b8\u00b6\3\2\2\2\u00b8\u00b9\3\2\2\2")
        buf.write("\u00b9\23\3\2\2\2\u00ba\u00b8\3\2\2\2\u00bb\u00bf\5\34")
        buf.write("\17\2\u00bc\u00bf\5$\23\2\u00bd\u00bf\5(\25\2\u00be\u00bb")
        buf.write("\3\2\2\2\u00be\u00bc\3\2\2\2\u00be\u00bd\3\2\2\2\u00bf")
        buf.write("\u00c5\3\2\2\2\u00c0\u00c4\5\34\17\2\u00c1\u00c4\5$\23")
        buf.write("\2\u00c2\u00c4\5&\24\2\u00c3\u00c0\3\2\2\2\u00c3\u00c1")
        buf.write("\3\2\2\2\u00c3\u00c2\3\2\2\2\u00c4\u00c7\3\2\2\2\u00c5")
        buf.write("\u00c3\3\2\2\2\u00c5\u00c6\3\2\2\2\u00c6\25\3\2\2\2\u00c7")
        buf.write("\u00c5\3\2\2\2\u00c8\u00c9\7\21\2\2\u00c9\27\3\2\2\2\u00ca")
        buf.write("\u00cb\7\22\2\2\u00cb\31\3\2\2\2\u00cc\u00cd\t\3\2\2\u00cd")
        buf.write("\33\3\2\2\2\u00ce\u00d2\5\36\20\2\u00cf\u00d2\5 \21\2")
        buf.write("\u00d0\u00d2\5\"\22\2\u00d1\u00ce\3\2\2\2\u00d1\u00cf")
        buf.write("\3\2\2\2\u00d1\u00d0\3\2\2\2\u00d2\35\3\2\2\2\u00d3\u00d4")
        buf.write("\t\4\2\2\u00d4\37\3\2\2\2\u00d5\u00d6\t\5\2\2\u00d6!\3")
        buf.write("\2\2\2\u00d7\u00d8\t\6\2\2\u00d8#\3\2\2\2\u00d9\u00da")
        buf.write("\t\7\2\2\u00da%\3\2\2\2\u00db\u00dc\7\64\2\2\u00dc\'\3")
        buf.write("\2\2\2\u00dd\u00de\t\b\2\2\u00de)\3\2\2\2\u00df\u00e2")
        buf.write("\5,\27\2\u00e0\u00e2\7@\2\2\u00e1\u00df\3\2\2\2\u00e1")
        buf.write("\u00e0\3\2\2\2\u00e2+\3\2\2\2\u00e3\u00e4\t\t\2\2\u00e4")
        buf.write("-\3\2\2\2\u00e5\u00e6\7>\2\2\u00e6\u00e7\7<\2\2\u00e7")
        buf.write("\u00e8\7?\2\2\u00e8\u00e9\7<\2\2\u00e9\u00fa\7>\2\2\u00ea")
        buf.write("\u00eb\7>\2\2\u00eb\u00ec\7<\2\2\u00ec\u00ed\7>\2\2\u00ed")
        buf.write("\u00ee\7<\2\2\u00ee\u00fa\7>\2\2\u00ef\u00f0\7?\2\2\u00f0")
        buf.write("\u00f1\7<\2\2\u00f1\u00f2\7>\2\2\u00f2\u00f3\7<\2\2\u00f3")
        buf.write("\u00fa\7>\2\2\u00f4\u00f5\7?\2\2\u00f5\u00f6\7<\2\2\u00f6")
        buf.write("\u00fa\7>\2\2\u00f7\u00fa\7?\2\2\u00f8\u00fa\7>\2\2\u00f9")
        buf.write("\u00e5\3\2\2\2\u00f9\u00ea\3\2\2\2\u00f9\u00ef\3\2\2\2")
        buf.write("\u00f9\u00f4\3\2\2\2\u00f9\u00f7\3\2\2\2\u00f9\u00f8\3")
        buf.write("\2\2\2\u00fa/\3\2\2\2\u00fb\u00fc\7=\2\2\u00fc\61\3\2")
        buf.write("\2\2!\67>DGL\\bmpuz~\u0083\u0088\u008c\u008f\u0094\u0099")
        buf.write("\u009d\u00a2\u00a7\u00ab\u00b0\u00b6\u00b8\u00be\u00c3")
        buf.write("\u00c5\u00d1\u00e1\u00f9")
        return buf.getvalue()


class nlParser ( Parser ):

    grammarFileName = "nl.g4"

    atn = ATNDeserializer().deserialize(serializedATN())

    decisionsToDFA = [ DFA(ds, i) for i, ds in enumerate(atn.decisionToState) ]

    sharedContextCache = PredictionContextCache()

    literalNames = [ "<INVALID>", "'why'", "'equal'", "'more than'", "'this'", 
                     "'less than'", "'with'", "'between'", "'for'", "'during'", 
                     "'since'", "'while'", "'when'", "'according to'", "','", 
                     "'DT'", "'and'", "'decrease'", "'increase'", "'low'", 
                     "'high'", "'stagnation'", "'stable'", "'evolve'", "'didn't evolve'", 
                     "'decreased'", "'increased'", "'NN'", "'NNS'", "'NNP'", 
                     "'NNPS'", "'quantity'", "'amount'", "'total'", "'number'", 
                     "'volume'", "'ratio'", "'percentage'", "'degree'", 
                     "'time'", "'year'", "'month'", "'day'", "'season'", 
                     "'hour'", "'minute'", "'seconde'", "'JJ'", "'JJR'", 
                     "'JJS'", "'VBN'", "'IN'", "'in'", "'VB'", "'VBG'", 
                     "'VBD'", "'VBP'", "'VBZ'", "'/'", "'?'", "'CD'" ]

    symbolicNames = [ "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "<INVALID>", "<INVALID>", "<INVALID>", "<INVALID>", 
                      "DIGIT", "MMM", "WORD", "EROOR_RECOGNITION", "WS" ]

    RULE_why_question = 0
    RULE_question_pronoun = 1
    RULE_fil_ter = 2
    RULE_temporel_dimension = 3
    RULE_filter_operator = 4
    RULE_dimension_marker = 5
    RULE_ng = 6
    RULE_ngf = 7
    RULE_ng1 = 8
    RULE_ng_f1 = 9
    RULE_determinant = 10
    RULE_conj_coordination = 11
    RULE_trend_indicator = 12
    RULE_nominal_term = 13
    RULE_noun = 14
    RULE_mesure_indicator = 15
    RULE_temporel_lexicon = 16
    RULE_adjective = 17
    RULE_past_participale = 18
    RULE_preposition = 19
    RULE_mg = 20
    RULE_verb = 21
    RULE_date = 22
    RULE_interogation = 23

    ruleNames =  [ "why_question", "question_pronoun", "fil_ter", "temporel_dimension", 
                   "filter_operator", "dimension_marker", "ng", "ngf", "ng1", 
                   "ng_f1", "determinant", "conj_coordination", "trend_indicator", 
                   "nominal_term", "noun", "mesure_indicator", "temporel_lexicon", 
                   "adjective", "past_participale", "preposition", "mg", 
                   "verb", "date", "interogation" ]

    EOF = Token.EOF
    T__0=1
    T__1=2
    T__2=3
    T__3=4
    T__4=5
    T__5=6
    T__6=7
    T__7=8
    T__8=9
    T__9=10
    T__10=11
    T__11=12
    T__12=13
    T__13=14
    T__14=15
    T__15=16
    T__16=17
    T__17=18
    T__18=19
    T__19=20
    T__20=21
    T__21=22
    T__22=23
    T__23=24
    T__24=25
    T__25=26
    T__26=27
    T__27=28
    T__28=29
    T__29=30
    T__30=31
    T__31=32
    T__32=33
    T__33=34
    T__34=35
    T__35=36
    T__36=37
    T__37=38
    T__38=39
    T__39=40
    T__40=41
    T__41=42
    T__42=43
    T__43=44
    T__44=45
    T__45=46
    T__46=47
    T__47=48
    T__48=49
    T__49=50
    T__50=51
    T__51=52
    T__52=53
    T__53=54
    T__54=55
    T__55=56
    T__56=57
    T__57=58
    T__58=59
    DIGIT=60
    MMM=61
    WORD=62
    EROOR_RECOGNITION=63
    WS=64

    def __init__(self, input:TokenStream, output:TextIO = sys.stdout):
        super().__init__(input, output)
        self.checkVersion("4.9.3")
        self._interp = ParserATNSimulator(self, self.atn, self.decisionsToDFA, self.sharedContextCache)
        self._predicates = None




    class Why_questionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return nlParser.RULE_why_question

     
        def copyFrom(self, ctx:ParserRuleContext):
            super().copyFrom(ctx)



    class ErrorContext(Why_questionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a nlParser.Why_questionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def EROOR_RECOGNITION(self):
            return self.getToken(nlParser.EROOR_RECOGNITION, 0)

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterError" ):
                listener.enterError(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitError" ):
                listener.exitError(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitError" ):
                return visitor.visitError(self)
            else:
                return visitor.visitChildren(self)


    class WhyExprContext(Why_questionContext):

        def __init__(self, parser, ctx:ParserRuleContext): # actually a nlParser.Why_questionContext
            super().__init__(parser)
            self.copyFrom(ctx)

        def question_pronoun(self):
            return self.getTypedRuleContext(nlParser.Question_pronounContext,0)

        def ng(self):
            return self.getTypedRuleContext(nlParser.NgContext,0)

        def trend_indicator(self):
            return self.getTypedRuleContext(nlParser.Trend_indicatorContext,0)

        def EOF(self):
            return self.getToken(nlParser.EOF, 0)
        def mg(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nlParser.MgContext)
            else:
                return self.getTypedRuleContext(nlParser.MgContext,i)

        def fil_ter(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nlParser.Fil_terContext)
            else:
                return self.getTypedRuleContext(nlParser.Fil_terContext,i)

        def interogation(self):
            return self.getTypedRuleContext(nlParser.InterogationContext,0)


        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterWhyExpr" ):
                listener.enterWhyExpr(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitWhyExpr" ):
                listener.exitWhyExpr(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitWhyExpr" ):
                return visitor.visitWhyExpr(self)
            else:
                return visitor.visitChildren(self)



    def why_question(self):

        localctx = nlParser.Why_questionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 0, self.RULE_why_question)
        self._la = 0 # Token type
        try:
            self.state = 74
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [nlParser.T__0]:
                localctx = nlParser.WhyExprContext(self, localctx)
                self.enterOuterAlt(localctx, 1)
                self.state = 48
                self.question_pronoun()
                self.state = 49
                self.ng()
                self.state = 53
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << nlParser.T__52) | (1 << nlParser.T__53) | (1 << nlParser.T__54) | (1 << nlParser.T__55) | (1 << nlParser.T__56) | (1 << nlParser.WORD))) != 0):
                    self.state = 50
                    self.mg()
                    self.state = 55
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 56
                self.trend_indicator()
                self.state = 60
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << nlParser.T__52) | (1 << nlParser.T__53) | (1 << nlParser.T__54) | (1 << nlParser.T__55) | (1 << nlParser.T__56) | (1 << nlParser.WORD))) != 0):
                    self.state = 57
                    self.mg()
                    self.state = 62
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 64 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 63
                    self.fil_ter()
                    self.state = 66 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not ((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << nlParser.T__1) | (1 << nlParser.T__2) | (1 << nlParser.T__3) | (1 << nlParser.T__4) | (1 << nlParser.T__5) | (1 << nlParser.T__6) | (1 << nlParser.T__7) | (1 << nlParser.T__8) | (1 << nlParser.T__9) | (1 << nlParser.T__10) | (1 << nlParser.T__11) | (1 << nlParser.T__12) | (1 << nlParser.T__50) | (1 << nlParser.T__51))) != 0)):
                        break

                self.state = 69
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==nlParser.T__58:
                    self.state = 68
                    self.interogation()


                self.state = 71
                self.match(nlParser.EOF)
                pass
            elif token in [nlParser.EROOR_RECOGNITION]:
                localctx = nlParser.ErrorContext(self, localctx)
                self.enterOuterAlt(localctx, 2)
                self.state = 73
                self.match(nlParser.EROOR_RECOGNITION)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Question_pronounContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return nlParser.RULE_question_pronoun

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterQuestion_pronoun" ):
                listener.enterQuestion_pronoun(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitQuestion_pronoun" ):
                listener.exitQuestion_pronoun(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitQuestion_pronoun" ):
                return visitor.visitQuestion_pronoun(self)
            else:
                return visitor.visitChildren(self)




    def question_pronoun(self):

        localctx = nlParser.Question_pronounContext(self, self._ctx, self.state)
        self.enterRule(localctx, 2, self.RULE_question_pronoun)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 76
            self.match(nlParser.T__0)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Fil_terContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def dimension_marker(self):
            return self.getTypedRuleContext(nlParser.Dimension_markerContext,0)


        def ngf(self):
            return self.getTypedRuleContext(nlParser.NgfContext,0)


        def temporel_dimension(self):
            return self.getTypedRuleContext(nlParser.Temporel_dimensionContext,0)


        def filter_operator(self):
            return self.getTypedRuleContext(nlParser.Filter_operatorContext,0)


        def getRuleIndex(self):
            return nlParser.RULE_fil_ter

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFil_ter" ):
                listener.enterFil_ter(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFil_ter" ):
                listener.exitFil_ter(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFil_ter" ):
                return visitor.visitFil_ter(self)
            else:
                return visitor.visitChildren(self)




    def fil_ter(self):

        localctx = nlParser.Fil_terContext(self, self._ctx, self.state)
        self.enterRule(localctx, 4, self.RULE_fil_ter)
        try:
            self.state = 90
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,5,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 78
                self.dimension_marker()
                self.state = 79
                self.ngf()
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 81
                self.dimension_marker()
                self.state = 82
                self.temporel_dimension()
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 84
                self.filter_operator()
                self.state = 85
                self.ngf()
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 87
                self.filter_operator()
                self.state = 88
                self.temporel_dimension()
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Temporel_dimensionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ng(self):
            return self.getTypedRuleContext(nlParser.NgContext,0)


        def date(self):
            return self.getTypedRuleContext(nlParser.DateContext,0)


        def getRuleIndex(self):
            return nlParser.RULE_temporel_dimension

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTemporel_dimension" ):
                listener.enterTemporel_dimension(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTemporel_dimension" ):
                listener.exitTemporel_dimension(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTemporel_dimension" ):
                return visitor.visitTemporel_dimension(self)
            else:
                return visitor.visitChildren(self)




    def temporel_dimension(self):

        localctx = nlParser.Temporel_dimensionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 6, self.RULE_temporel_dimension)
        try:
            self.state = 96
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [nlParser.T__14, nlParser.T__26, nlParser.T__27, nlParser.T__28, nlParser.T__29, nlParser.T__30, nlParser.T__31, nlParser.T__32, nlParser.T__33, nlParser.T__34, nlParser.T__35, nlParser.T__36, nlParser.T__37, nlParser.T__38, nlParser.T__39, nlParser.T__40, nlParser.T__41, nlParser.T__42, nlParser.T__43, nlParser.T__44, nlParser.T__45, nlParser.T__46, nlParser.T__47, nlParser.T__48, nlParser.T__50, nlParser.T__51]:
                self.enterOuterAlt(localctx, 1)
                self.state = 92
                self.ng()
                self.state = 93
                self.date()
                pass
            elif token in [nlParser.DIGIT, nlParser.MMM]:
                self.enterOuterAlt(localctx, 2)
                self.state = 95
                self.date()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Filter_operatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return nlParser.RULE_filter_operator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterFilter_operator" ):
                listener.enterFilter_operator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitFilter_operator" ):
                listener.exitFilter_operator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitFilter_operator" ):
                return visitor.visitFilter_operator(self)
            else:
                return visitor.visitChildren(self)




    def filter_operator(self):

        localctx = nlParser.Filter_operatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 8, self.RULE_filter_operator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 98
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << nlParser.T__1) | (1 << nlParser.T__2) | (1 << nlParser.T__3) | (1 << nlParser.T__4) | (1 << nlParser.T__5) | (1 << nlParser.T__6))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Dimension_markerContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def preposition(self):
            return self.getTypedRuleContext(nlParser.PrepositionContext,0)


        def getRuleIndex(self):
            return nlParser.RULE_dimension_marker

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDimension_marker" ):
                listener.enterDimension_marker(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDimension_marker" ):
                listener.exitDimension_marker(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDimension_marker" ):
                return visitor.visitDimension_marker(self)
            else:
                return visitor.visitChildren(self)




    def dimension_marker(self):

        localctx = nlParser.Dimension_markerContext(self, self._ctx, self.state)
        self.enterRule(localctx, 10, self.RULE_dimension_marker)
        try:
            self.state = 107
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [nlParser.T__7]:
                self.enterOuterAlt(localctx, 1)
                self.state = 100
                self.match(nlParser.T__7)
                pass
            elif token in [nlParser.T__8]:
                self.enterOuterAlt(localctx, 2)
                self.state = 101
                self.match(nlParser.T__8)
                pass
            elif token in [nlParser.T__50, nlParser.T__51]:
                self.enterOuterAlt(localctx, 3)
                self.state = 102
                self.preposition()
                pass
            elif token in [nlParser.T__9]:
                self.enterOuterAlt(localctx, 4)
                self.state = 103
                self.match(nlParser.T__9)
                pass
            elif token in [nlParser.T__10]:
                self.enterOuterAlt(localctx, 5)
                self.state = 104
                self.match(nlParser.T__10)
                pass
            elif token in [nlParser.T__11]:
                self.enterOuterAlt(localctx, 6)
                self.state = 105
                self.match(nlParser.T__11)
                pass
            elif token in [nlParser.T__12]:
                self.enterOuterAlt(localctx, 7)
                self.state = 106
                self.match(nlParser.T__12)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NgContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ng1(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nlParser.Ng1Context)
            else:
                return self.getTypedRuleContext(nlParser.Ng1Context,i)


        def determinant(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nlParser.DeterminantContext)
            else:
                return self.getTypedRuleContext(nlParser.DeterminantContext,i)


        def conj_coordination(self):
            return self.getTypedRuleContext(nlParser.Conj_coordinationContext,0)


        def getRuleIndex(self):
            return nlParser.RULE_ng

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNg" ):
                listener.enterNg(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNg" ):
                listener.exitNg(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNg" ):
                return visitor.visitNg(self)
            else:
                return visitor.visitChildren(self)




    def ng(self):

        localctx = nlParser.NgContext(self, self._ctx, self.state)
        self.enterRule(localctx, 12, self.RULE_ng)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 110
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==nlParser.T__14:
                self.state = 109
                self.determinant()


            self.state = 112
            self.ng1()
            self.state = 138
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,14,self._ctx)
            if la_ == 1:
                self.state = 118 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 113
                    self.match(nlParser.T__13)
                    self.state = 115
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==nlParser.T__14:
                        self.state = 114
                        self.determinant()


                    self.state = 117
                    self.ng1()
                    self.state = 120 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==nlParser.T__13):
                        break


            elif la_ == 2:
                self.state = 129
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==nlParser.T__13:
                    self.state = 122
                    self.match(nlParser.T__13)
                    self.state = 124
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==nlParser.T__14:
                        self.state = 123
                        self.determinant()


                    self.state = 126
                    self.ng1()
                    self.state = 131
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 132
                self.conj_coordination()
                self.state = 134
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==nlParser.T__14:
                    self.state = 133
                    self.determinant()


                self.state = 136
                self.ng1()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NgfContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def ng_f1(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nlParser.Ng_f1Context)
            else:
                return self.getTypedRuleContext(nlParser.Ng_f1Context,i)


        def determinant(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nlParser.DeterminantContext)
            else:
                return self.getTypedRuleContext(nlParser.DeterminantContext,i)


        def conj_coordination(self):
            return self.getTypedRuleContext(nlParser.Conj_coordinationContext,0)


        def getRuleIndex(self):
            return nlParser.RULE_ngf

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNgf" ):
                listener.enterNgf(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNgf" ):
                listener.exitNgf(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNgf" ):
                return visitor.visitNgf(self)
            else:
                return visitor.visitChildren(self)




    def ngf(self):

        localctx = nlParser.NgfContext(self, self._ctx, self.state)
        self.enterRule(localctx, 14, self.RULE_ngf)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 141
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            if _la==nlParser.T__14:
                self.state = 140
                self.determinant()


            self.state = 143
            self.ng_f1()
            self.state = 169
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,21,self._ctx)
            if la_ == 1:
                self.state = 149 
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while True:
                    self.state = 144
                    self.match(nlParser.T__13)
                    self.state = 146
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==nlParser.T__14:
                        self.state = 145
                        self.determinant()


                    self.state = 148
                    self.ng_f1()
                    self.state = 151 
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if not (_la==nlParser.T__13):
                        break


            elif la_ == 2:
                self.state = 160
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                while _la==nlParser.T__13:
                    self.state = 153
                    self.match(nlParser.T__13)
                    self.state = 155
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)
                    if _la==nlParser.T__14:
                        self.state = 154
                        self.determinant()


                    self.state = 157
                    self.ng_f1()
                    self.state = 162
                    self._errHandler.sync(self)
                    _la = self._input.LA(1)

                self.state = 163
                self.conj_coordination()
                self.state = 165
                self._errHandler.sync(self)
                _la = self._input.LA(1)
                if _la==nlParser.T__14:
                    self.state = 164
                    self.determinant()


                self.state = 167
                self.ng_f1()


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Ng1Context(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def nominal_term(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nlParser.Nominal_termContext)
            else:
                return self.getTypedRuleContext(nlParser.Nominal_termContext,i)


        def adjective(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nlParser.AdjectiveContext)
            else:
                return self.getTypedRuleContext(nlParser.AdjectiveContext,i)


        def preposition(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nlParser.PrepositionContext)
            else:
                return self.getTypedRuleContext(nlParser.PrepositionContext,i)


        def past_participale(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nlParser.Past_participaleContext)
            else:
                return self.getTypedRuleContext(nlParser.Past_participaleContext,i)


        def getRuleIndex(self):
            return nlParser.RULE_ng1

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNg1" ):
                listener.enterNg1(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNg1" ):
                listener.exitNg1(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNg1" ):
                return visitor.visitNg1(self)
            else:
                return visitor.visitChildren(self)




    def ng1(self):

        localctx = nlParser.Ng1Context(self, self._ctx, self.state)
        self.enterRule(localctx, 16, self.RULE_ng1)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 174
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [nlParser.T__26, nlParser.T__27, nlParser.T__28, nlParser.T__29, nlParser.T__30, nlParser.T__31, nlParser.T__32, nlParser.T__33, nlParser.T__34, nlParser.T__35, nlParser.T__36, nlParser.T__37, nlParser.T__38, nlParser.T__39, nlParser.T__40, nlParser.T__41, nlParser.T__42, nlParser.T__43, nlParser.T__44, nlParser.T__45]:
                self.state = 171
                self.nominal_term()
                pass
            elif token in [nlParser.T__46, nlParser.T__47, nlParser.T__48]:
                self.state = 172
                self.adjective()
                pass
            elif token in [nlParser.T__50, nlParser.T__51]:
                self.state = 173
                self.preposition()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 182
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << nlParser.T__26) | (1 << nlParser.T__27) | (1 << nlParser.T__28) | (1 << nlParser.T__29) | (1 << nlParser.T__30) | (1 << nlParser.T__31) | (1 << nlParser.T__32) | (1 << nlParser.T__33) | (1 << nlParser.T__34) | (1 << nlParser.T__35) | (1 << nlParser.T__36) | (1 << nlParser.T__37) | (1 << nlParser.T__38) | (1 << nlParser.T__39) | (1 << nlParser.T__40) | (1 << nlParser.T__41) | (1 << nlParser.T__42) | (1 << nlParser.T__43) | (1 << nlParser.T__44) | (1 << nlParser.T__45) | (1 << nlParser.T__46) | (1 << nlParser.T__47) | (1 << nlParser.T__48) | (1 << nlParser.T__49) | (1 << nlParser.T__50) | (1 << nlParser.T__51))) != 0):
                self.state = 180
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [nlParser.T__26, nlParser.T__27, nlParser.T__28, nlParser.T__29, nlParser.T__30, nlParser.T__31, nlParser.T__32, nlParser.T__33, nlParser.T__34, nlParser.T__35, nlParser.T__36, nlParser.T__37, nlParser.T__38, nlParser.T__39, nlParser.T__40, nlParser.T__41, nlParser.T__42, nlParser.T__43, nlParser.T__44, nlParser.T__45]:
                    self.state = 176
                    self.nominal_term()
                    pass
                elif token in [nlParser.T__46, nlParser.T__47, nlParser.T__48]:
                    self.state = 177
                    self.adjective()
                    pass
                elif token in [nlParser.T__49]:
                    self.state = 178
                    self.past_participale()
                    pass
                elif token in [nlParser.T__50, nlParser.T__51]:
                    self.state = 179
                    self.preposition()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 184
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Ng_f1Context(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def nominal_term(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nlParser.Nominal_termContext)
            else:
                return self.getTypedRuleContext(nlParser.Nominal_termContext,i)


        def adjective(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nlParser.AdjectiveContext)
            else:
                return self.getTypedRuleContext(nlParser.AdjectiveContext,i)


        def preposition(self):
            return self.getTypedRuleContext(nlParser.PrepositionContext,0)


        def past_participale(self, i:int=None):
            if i is None:
                return self.getTypedRuleContexts(nlParser.Past_participaleContext)
            else:
                return self.getTypedRuleContext(nlParser.Past_participaleContext,i)


        def getRuleIndex(self):
            return nlParser.RULE_ng_f1

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNg_f1" ):
                listener.enterNg_f1(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNg_f1" ):
                listener.exitNg_f1(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNg_f1" ):
                return visitor.visitNg_f1(self)
            else:
                return visitor.visitChildren(self)




    def ng_f1(self):

        localctx = nlParser.Ng_f1Context(self, self._ctx, self.state)
        self.enterRule(localctx, 18, self.RULE_ng_f1)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 188
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [nlParser.T__26, nlParser.T__27, nlParser.T__28, nlParser.T__29, nlParser.T__30, nlParser.T__31, nlParser.T__32, nlParser.T__33, nlParser.T__34, nlParser.T__35, nlParser.T__36, nlParser.T__37, nlParser.T__38, nlParser.T__39, nlParser.T__40, nlParser.T__41, nlParser.T__42, nlParser.T__43, nlParser.T__44, nlParser.T__45]:
                self.state = 185
                self.nominal_term()
                pass
            elif token in [nlParser.T__46, nlParser.T__47, nlParser.T__48]:
                self.state = 186
                self.adjective()
                pass
            elif token in [nlParser.T__50, nlParser.T__51]:
                self.state = 187
                self.preposition()
                pass
            else:
                raise NoViableAltException(self)

            self.state = 195
            self._errHandler.sync(self)
            _la = self._input.LA(1)
            while (((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << nlParser.T__26) | (1 << nlParser.T__27) | (1 << nlParser.T__28) | (1 << nlParser.T__29) | (1 << nlParser.T__30) | (1 << nlParser.T__31) | (1 << nlParser.T__32) | (1 << nlParser.T__33) | (1 << nlParser.T__34) | (1 << nlParser.T__35) | (1 << nlParser.T__36) | (1 << nlParser.T__37) | (1 << nlParser.T__38) | (1 << nlParser.T__39) | (1 << nlParser.T__40) | (1 << nlParser.T__41) | (1 << nlParser.T__42) | (1 << nlParser.T__43) | (1 << nlParser.T__44) | (1 << nlParser.T__45) | (1 << nlParser.T__46) | (1 << nlParser.T__47) | (1 << nlParser.T__48) | (1 << nlParser.T__49))) != 0):
                self.state = 193
                self._errHandler.sync(self)
                token = self._input.LA(1)
                if token in [nlParser.T__26, nlParser.T__27, nlParser.T__28, nlParser.T__29, nlParser.T__30, nlParser.T__31, nlParser.T__32, nlParser.T__33, nlParser.T__34, nlParser.T__35, nlParser.T__36, nlParser.T__37, nlParser.T__38, nlParser.T__39, nlParser.T__40, nlParser.T__41, nlParser.T__42, nlParser.T__43, nlParser.T__44, nlParser.T__45]:
                    self.state = 190
                    self.nominal_term()
                    pass
                elif token in [nlParser.T__46, nlParser.T__47, nlParser.T__48]:
                    self.state = 191
                    self.adjective()
                    pass
                elif token in [nlParser.T__49]:
                    self.state = 192
                    self.past_participale()
                    pass
                else:
                    raise NoViableAltException(self)

                self.state = 197
                self._errHandler.sync(self)
                _la = self._input.LA(1)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DeterminantContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return nlParser.RULE_determinant

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDeterminant" ):
                listener.enterDeterminant(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDeterminant" ):
                listener.exitDeterminant(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDeterminant" ):
                return visitor.visitDeterminant(self)
            else:
                return visitor.visitChildren(self)




    def determinant(self):

        localctx = nlParser.DeterminantContext(self, self._ctx, self.state)
        self.enterRule(localctx, 20, self.RULE_determinant)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 198
            self.match(nlParser.T__14)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Conj_coordinationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return nlParser.RULE_conj_coordination

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterConj_coordination" ):
                listener.enterConj_coordination(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitConj_coordination" ):
                listener.exitConj_coordination(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitConj_coordination" ):
                return visitor.visitConj_coordination(self)
            else:
                return visitor.visitChildren(self)




    def conj_coordination(self):

        localctx = nlParser.Conj_coordinationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 22, self.RULE_conj_coordination)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 200
            self.match(nlParser.T__15)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Trend_indicatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return nlParser.RULE_trend_indicator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTrend_indicator" ):
                listener.enterTrend_indicator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTrend_indicator" ):
                listener.exitTrend_indicator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTrend_indicator" ):
                return visitor.visitTrend_indicator(self)
            else:
                return visitor.visitChildren(self)




    def trend_indicator(self):

        localctx = nlParser.Trend_indicatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 24, self.RULE_trend_indicator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 202
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << nlParser.T__16) | (1 << nlParser.T__17) | (1 << nlParser.T__18) | (1 << nlParser.T__19) | (1 << nlParser.T__20) | (1 << nlParser.T__21) | (1 << nlParser.T__22) | (1 << nlParser.T__23) | (1 << nlParser.T__24) | (1 << nlParser.T__25))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Nominal_termContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def noun(self):
            return self.getTypedRuleContext(nlParser.NounContext,0)


        def mesure_indicator(self):
            return self.getTypedRuleContext(nlParser.Mesure_indicatorContext,0)


        def temporel_lexicon(self):
            return self.getTypedRuleContext(nlParser.Temporel_lexiconContext,0)


        def getRuleIndex(self):
            return nlParser.RULE_nominal_term

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNominal_term" ):
                listener.enterNominal_term(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNominal_term" ):
                listener.exitNominal_term(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNominal_term" ):
                return visitor.visitNominal_term(self)
            else:
                return visitor.visitChildren(self)




    def nominal_term(self):

        localctx = nlParser.Nominal_termContext(self, self._ctx, self.state)
        self.enterRule(localctx, 26, self.RULE_nominal_term)
        try:
            self.state = 207
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [nlParser.T__26, nlParser.T__27, nlParser.T__28, nlParser.T__29]:
                self.enterOuterAlt(localctx, 1)
                self.state = 204
                self.noun()
                pass
            elif token in [nlParser.T__30, nlParser.T__31, nlParser.T__32, nlParser.T__33, nlParser.T__34, nlParser.T__35, nlParser.T__36, nlParser.T__37]:
                self.enterOuterAlt(localctx, 2)
                self.state = 205
                self.mesure_indicator()
                pass
            elif token in [nlParser.T__38, nlParser.T__39, nlParser.T__40, nlParser.T__41, nlParser.T__42, nlParser.T__43, nlParser.T__44, nlParser.T__45]:
                self.enterOuterAlt(localctx, 3)
                self.state = 206
                self.temporel_lexicon()
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class NounContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return nlParser.RULE_noun

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterNoun" ):
                listener.enterNoun(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitNoun" ):
                listener.exitNoun(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitNoun" ):
                return visitor.visitNoun(self)
            else:
                return visitor.visitChildren(self)




    def noun(self):

        localctx = nlParser.NounContext(self, self._ctx, self.state)
        self.enterRule(localctx, 28, self.RULE_noun)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 209
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << nlParser.T__26) | (1 << nlParser.T__27) | (1 << nlParser.T__28) | (1 << nlParser.T__29))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Mesure_indicatorContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return nlParser.RULE_mesure_indicator

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMesure_indicator" ):
                listener.enterMesure_indicator(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMesure_indicator" ):
                listener.exitMesure_indicator(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMesure_indicator" ):
                return visitor.visitMesure_indicator(self)
            else:
                return visitor.visitChildren(self)




    def mesure_indicator(self):

        localctx = nlParser.Mesure_indicatorContext(self, self._ctx, self.state)
        self.enterRule(localctx, 30, self.RULE_mesure_indicator)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 211
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << nlParser.T__30) | (1 << nlParser.T__31) | (1 << nlParser.T__32) | (1 << nlParser.T__33) | (1 << nlParser.T__34) | (1 << nlParser.T__35) | (1 << nlParser.T__36) | (1 << nlParser.T__37))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Temporel_lexiconContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return nlParser.RULE_temporel_lexicon

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterTemporel_lexicon" ):
                listener.enterTemporel_lexicon(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitTemporel_lexicon" ):
                listener.exitTemporel_lexicon(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitTemporel_lexicon" ):
                return visitor.visitTemporel_lexicon(self)
            else:
                return visitor.visitChildren(self)




    def temporel_lexicon(self):

        localctx = nlParser.Temporel_lexiconContext(self, self._ctx, self.state)
        self.enterRule(localctx, 32, self.RULE_temporel_lexicon)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 213
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << nlParser.T__38) | (1 << nlParser.T__39) | (1 << nlParser.T__40) | (1 << nlParser.T__41) | (1 << nlParser.T__42) | (1 << nlParser.T__43) | (1 << nlParser.T__44) | (1 << nlParser.T__45))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class AdjectiveContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return nlParser.RULE_adjective

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterAdjective" ):
                listener.enterAdjective(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitAdjective" ):
                listener.exitAdjective(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitAdjective" ):
                return visitor.visitAdjective(self)
            else:
                return visitor.visitChildren(self)




    def adjective(self):

        localctx = nlParser.AdjectiveContext(self, self._ctx, self.state)
        self.enterRule(localctx, 34, self.RULE_adjective)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 215
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << nlParser.T__46) | (1 << nlParser.T__47) | (1 << nlParser.T__48))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class Past_participaleContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return nlParser.RULE_past_participale

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPast_participale" ):
                listener.enterPast_participale(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPast_participale" ):
                listener.exitPast_participale(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPast_participale" ):
                return visitor.visitPast_participale(self)
            else:
                return visitor.visitChildren(self)




    def past_participale(self):

        localctx = nlParser.Past_participaleContext(self, self._ctx, self.state)
        self.enterRule(localctx, 36, self.RULE_past_participale)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 217
            self.match(nlParser.T__49)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class PrepositionContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return nlParser.RULE_preposition

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterPreposition" ):
                listener.enterPreposition(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitPreposition" ):
                listener.exitPreposition(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitPreposition" ):
                return visitor.visitPreposition(self)
            else:
                return visitor.visitChildren(self)




    def preposition(self):

        localctx = nlParser.PrepositionContext(self, self._ctx, self.state)
        self.enterRule(localctx, 38, self.RULE_preposition)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 219
            _la = self._input.LA(1)
            if not(_la==nlParser.T__50 or _la==nlParser.T__51):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class MgContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def verb(self):
            return self.getTypedRuleContext(nlParser.VerbContext,0)


        def WORD(self):
            return self.getToken(nlParser.WORD, 0)

        def getRuleIndex(self):
            return nlParser.RULE_mg

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterMg" ):
                listener.enterMg(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitMg" ):
                listener.exitMg(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitMg" ):
                return visitor.visitMg(self)
            else:
                return visitor.visitChildren(self)




    def mg(self):

        localctx = nlParser.MgContext(self, self._ctx, self.state)
        self.enterRule(localctx, 40, self.RULE_mg)
        try:
            self.state = 223
            self._errHandler.sync(self)
            token = self._input.LA(1)
            if token in [nlParser.T__52, nlParser.T__53, nlParser.T__54, nlParser.T__55, nlParser.T__56]:
                self.enterOuterAlt(localctx, 1)
                self.state = 221
                self.verb()
                pass
            elif token in [nlParser.WORD]:
                self.enterOuterAlt(localctx, 2)
                self.state = 222
                self.match(nlParser.WORD)
                pass
            else:
                raise NoViableAltException(self)

        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class VerbContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return nlParser.RULE_verb

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterVerb" ):
                listener.enterVerb(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitVerb" ):
                listener.exitVerb(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitVerb" ):
                return visitor.visitVerb(self)
            else:
                return visitor.visitChildren(self)




    def verb(self):

        localctx = nlParser.VerbContext(self, self._ctx, self.state)
        self.enterRule(localctx, 42, self.RULE_verb)
        self._la = 0 # Token type
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 225
            _la = self._input.LA(1)
            if not((((_la) & ~0x3f) == 0 and ((1 << _la) & ((1 << nlParser.T__52) | (1 << nlParser.T__53) | (1 << nlParser.T__54) | (1 << nlParser.T__55) | (1 << nlParser.T__56))) != 0)):
                self._errHandler.recoverInline(self)
            else:
                self._errHandler.reportMatch(self)
                self.consume()
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class DateContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser

        def DIGIT(self, i:int=None):
            if i is None:
                return self.getTokens(nlParser.DIGIT)
            else:
                return self.getToken(nlParser.DIGIT, i)

        def MMM(self):
            return self.getToken(nlParser.MMM, 0)

        def getRuleIndex(self):
            return nlParser.RULE_date

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterDate" ):
                listener.enterDate(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitDate" ):
                listener.exitDate(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitDate" ):
                return visitor.visitDate(self)
            else:
                return visitor.visitChildren(self)




    def date(self):

        localctx = nlParser.DateContext(self, self._ctx, self.state)
        self.enterRule(localctx, 44, self.RULE_date)
        try:
            self.state = 247
            self._errHandler.sync(self)
            la_ = self._interp.adaptivePredict(self._input,30,self._ctx)
            if la_ == 1:
                self.enterOuterAlt(localctx, 1)
                self.state = 227
                self.match(nlParser.DIGIT)
                self.state = 228
                self.match(nlParser.T__57)
                self.state = 229
                self.match(nlParser.MMM)
                self.state = 230
                self.match(nlParser.T__57)
                self.state = 231
                self.match(nlParser.DIGIT)
                pass

            elif la_ == 2:
                self.enterOuterAlt(localctx, 2)
                self.state = 232
                self.match(nlParser.DIGIT)
                self.state = 233
                self.match(nlParser.T__57)
                self.state = 234
                self.match(nlParser.DIGIT)
                self.state = 235
                self.match(nlParser.T__57)
                self.state = 236
                self.match(nlParser.DIGIT)
                pass

            elif la_ == 3:
                self.enterOuterAlt(localctx, 3)
                self.state = 237
                self.match(nlParser.MMM)
                self.state = 238
                self.match(nlParser.T__57)
                self.state = 239
                self.match(nlParser.DIGIT)
                self.state = 240
                self.match(nlParser.T__57)
                self.state = 241
                self.match(nlParser.DIGIT)
                pass

            elif la_ == 4:
                self.enterOuterAlt(localctx, 4)
                self.state = 242
                self.match(nlParser.MMM)
                self.state = 243
                self.match(nlParser.T__57)
                self.state = 244
                self.match(nlParser.DIGIT)
                pass

            elif la_ == 5:
                self.enterOuterAlt(localctx, 5)
                self.state = 245
                self.match(nlParser.MMM)
                pass

            elif la_ == 6:
                self.enterOuterAlt(localctx, 6)
                self.state = 246
                self.match(nlParser.DIGIT)
                pass


        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx


    class InterogationContext(ParserRuleContext):
        __slots__ = 'parser'

        def __init__(self, parser, parent:ParserRuleContext=None, invokingState:int=-1):
            super().__init__(parent, invokingState)
            self.parser = parser


        def getRuleIndex(self):
            return nlParser.RULE_interogation

        def enterRule(self, listener:ParseTreeListener):
            if hasattr( listener, "enterInterogation" ):
                listener.enterInterogation(self)

        def exitRule(self, listener:ParseTreeListener):
            if hasattr( listener, "exitInterogation" ):
                listener.exitInterogation(self)

        def accept(self, visitor:ParseTreeVisitor):
            if hasattr( visitor, "visitInterogation" ):
                return visitor.visitInterogation(self)
            else:
                return visitor.visitChildren(self)




    def interogation(self):

        localctx = nlParser.InterogationContext(self, self._ctx, self.state)
        self.enterRule(localctx, 46, self.RULE_interogation)
        try:
            self.enterOuterAlt(localctx, 1)
            self.state = 249
            self.match(nlParser.T__58)
        except RecognitionException as re:
            localctx.exception = re
            self._errHandler.reportError(self, re)
            self._errHandler.recover(self, re)
        finally:
            self.exitRule()
        return localctx





